private EditorObject getObject(int x, int y) {
EditorObject result = null;
List<GameObject> objects = rootObject.getGameObjects(new ArrayList<>());
int depth = Integer.MIN_VALUE;
for (GameObject object: objects) {
    if (object.localAABB().contains(x, y) && object.getTransform().depth > depth) {
        result = (EditorObject) object;
        depth = object.getTransform().depth;
    }
}
return result;
}

private List<EditorObject> getObjects(Rectangle bounds) {
List<GameObject> objects = rootObject.getGameObjects(new ArrayList<>());
List<EditorObject> result = new ArrayList<>();
for (GameObject object: objects) {
    if (bounds.contains(object.localAABB())) {
        result.add((EditorObject) object);
    }
}
return result;
}        


public void addObject(EditorObject object) {
    rootObject.addChild(object);
    graph.refreshGraph(rootObject);
}

public void clearSelectedObjects() {
    selectedObjects.clear();
}

public void addSelectedObject(EditorObject object) {
    selectedObjects.add(object);
}

public void removeSelectedObject(EditorObject object) {
    try {
        selectedObjects.remove(object);
    } catch (Exception e) {
    }
}

public void transformObjects(Collection<EditorObject> objects, Transform2D transform) {
    for (EditorObject object: objects) {
        object.getTransform().translate(transform.position);
        object.getTransform().rotate(transform.rotation);
        object.getTransform().scale(transform.scale);
    }
}

private void gridTransformObjects(Collection<EditorObject> objects) {
    for (EditorObject object: objects) {
        object.getTransform().position.x = (int) (object.getTransform().position.x / 32) * 32;
        object.getTransform().position.y = (int) (object.getTransform().position.y / 32) * 32;
    }
}

public void removeObject(EditorObject object) {
    removeObject(rootObject, object);
    graph.refreshGraph(rootObject); 
}

private EditorObject removeObject(EditorObject in, EditorObject object) {
    if (in.equals(object))
        return object;

    for (GameObject o: in.getChildren()) {
        EditorObject removed = removeObject((EditorObject) o, object);
        if (removed != null) {
            in.getChildren().remove(removed);
            break;
        }
    }

    return null;
}

private Rectangle getRange(Set<EditorObject> objects) {
    int sx = Integer.MAX_VALUE;
    int sy = Integer.MAX_VALUE;
    int ex = Integer.MIN_VALUE;
    int ey = Integer.MIN_VALUE;

    for (EditorObject object: objects) {
        Rectangle bounds = object.localAABB();
        if (bounds.x < sx)
            sx = bounds.x;
        if (bounds.x + bounds.width > ex)
            ex = bounds.x + bounds.width;
        if (bounds.y < sy)
            sy = bounds.y;
        if (bounds.y + bounds.height > ey)
            ey = bounds.y + bounds.height;
    }

    return new Rectangle(sx, sy, ex - sx, ey - sy);
}


pane.setOnMousePressed((MouseEvent event) -> {
    x = (int) event.getX();
    y = (int) event.getY();
    prevX = (int) event.getX();
    prevY = (int) event.getY();
    if (selectionRange != null && !event.isControlDown() && !event.isShiftDown()) {
        if (selectionRange.contains((int) event.getX(), (int) event.getY())) {
            transforming = true;
        }
    } else {
        transforming = false;
    }
});
pane.setOnMouseDragged((MouseEvent event) -> {
    dragging = true;

    if (transforming) {
        Vector2D translate = new Vector2D(event.getX() - prevX, event.getY() - prevY);
        Vector2D scale = new Vector2D();
        double rotate = 0;

        transformObjects(selectedObjects, new Transform2D(null, translate, new Vector2D(), rotate, scale, 0));
        placingObjects.addAll(selectedObjects);
        render();

    } else {
        render();
        int sx = Math.min(x, (int) event.getX());
        int sy = Math.min(y, (int) event.getY());
        int w = Math.max(x, (int) event.getX()) - sx;
        int h = Math.max(y, (int) event.getY()) - sy;
//                renderSelection(new Rectangle(sx, sy, w, h));
    }

    prevX = (int) event.getX();
    prevY = (int) event.getY();
});
pane.setOnMouseReleased((MouseEvent event) -> {
    if (!event.isControlDown() && !event.isShiftDown() && (!transforming || !dragging)) {
        selectedObjects.clear();
        selectionRange = null;
    }
    placingObjects.clear();
    placingRange = null;

    if (showGrid) {
        gridTransformObjects(selectedObjects);
    }

    if (!transforming || !dragging) {
        if (dragging) {
            int sx = Math.min(x, (int) event.getX());
            int sy = Math.min(y, (int) event.getY());
            int w = Math.max(x, (int) event.getX()) - sx;
            int h = Math.max(y, (int) event.getY()) - sy;

            List<EditorObject> objects = getObjects(new Rectangle(sx, sy, w, h));
            if (event.isControlDown()) {
                selectedObjects.removeAll(objects);
            } else {
                selectedObjects.addAll(objects);
            }
        } else {
            EditorObject object = getObject((int) event.getX(), (int) event.getY());
            if (object != null) {
                if (event.isControlDown()) {
                    selectedObjects.remove(object);
                } else {
                    selectedObjects.add(object);
                }
            }
        }
    }
    graph.setAllSelections(selectedObjects);
    transforming = false;
    dragging = false;
    render();
});
pane.setOnKeyPressed((KeyEvent event) -> {

});
pane.setOnDragDone((DragEvent event) -> {
    placingObjects.clear();
    placingRange = null;
    render();
});
pane.setOnDragExited((DragEvent event) -> {
    placingObjects.clear();
    placingRange = null;
    render();
});
pane.setOnDragDropped((DragEvent event) -> {
    placingObjects.clear();
    placingRange = null;
    if (event.getDragboard().hasContent(DataFormat.FILES)) {
        File resource = event.getDragboard().getFiles().get(0);
        if (resource.exists()) {
            String ext = Core.getExtension(resource.getName());
            switch (ext) {
                case "png": case "jpg": case "gif":
                    Image image = new Image("file:"+resource.getPath());
                    Vector2D position = new Vector2D(event.getX(), event.getY());
                    if (showGrid) {
                        position.x = (int) (position.x / tileSize) * tileSize;
                        position.y = (int) (position.y / tileSize) * tileSize;
                    }
                    EditorObject result = new EditorObject(Core.getFilename(resource.getName()), new Transform2D(null, position.x, position.y));
                    result.setAABB(0, 0, (int) image.getWidth(), (int) image.getHeight());
                    result.addComponent(new ImageRenderer(image));
                    addObject(result);
                    selectedObjects.clear();
                    selectedObjects.add(result);
                    graph.setSelection(result);
                    render();
                    break;
            }
        }
    } else if (event.getDragboard().hasContent(DataFormat.PLAIN_TEXT)) {

    }
});
pane.setOnDragOver((DragEvent event) -> {
    if (event.getDragboard().hasContent(DataFormat.FILES)) {
        File resource = event.getDragboard().getFiles().get(0);
        if (resource.exists()) {
            String ext = Core.getExtension(resource.getName());
            event.acceptTransferModes(TransferMode.MOVE);
            if (placingObjects.isEmpty()) { 
                switch (ext) {
                    case "png": case "jpg": case "gif":
                        Image image = new Image("file:"+resource.getPath());
                        EditorObject object = new EditorObject("");
                        object.setAABB(0, 0, (int) image.getWidth(), (int) image.getHeight());
                        object.addComponent(new ImageRenderer(image));
                        placingObjects.add(object);
                        break;
                }
            }
            if (!placingObjects.isEmpty()) {
                for (EditorObject object: placingObjects) {
                    object.getTransform().position.x = event.getX();
                    object.getTransform().position.y = event.getY();
                }
                render();
            }
        }
    } else if (event.getDragboard().hasContent(DataFormat.PLAIN_TEXT)) {

    }
});